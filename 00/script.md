```cpp
Hoge a;
Hoge b{std::move(a)};
```

(？？？？？？？？？？

「まじわかんない……

「さて, そろそろ休憩しますか……

ねねから電話がかかってくる

「はい, うみこですが

「もしもし, ねねです♪今だいじょうぶですかー？

「いいですよ, なんですか

「C++ の std::move とかいうやつがわかんないんですけどー

*OP*

「こういうものかと思ったんですけど……？

```cpp
int a = 1;
int b = std::move(a);
```

「あー, ……それだと意味ないですね

「そーなんですかー？

「えぇ, インスタンスとかじゃないと効果がありませんね

「そうだったのか……どういう仕組みなの？これ

「先に所有権に慣れておきましょうか

「ファイルを開いたり, メモリを確保したり, …こういったリソースの確保は, その後に解放をしたいことが往々にしてあります

「`new` で確保する場合も 1 回だけ `delete` しないといけないんですよね

「所有権は, 変数 1 つだけがリソース 1 つを管理する権利のことです

「1 つだけ?

「はい, 変数 1 つだけが解放を担うようにすることでリソースリークや二重解放を防ぎます

「なるほどー

「それでムーブセマンティクスとは, 別の変数へ所有権を移すことです

「所有権を移す?

「別の変数へ中身を移した後, 移す前の変数はもう解放しないようにするんです

「あー, それなら別の変数に移っても正しく解放できるんですね♪

「ムーブセマンティクスの要点はこんな感じです

1. 変数 `a` の所有権を変数 `b` に移したい
2. `a` を `b` に移す
3. `a` を無効にする

「うーん??? いまいちわかんないかも

「じゃあ会話っぽくしますか

> b「はじめまして a さん, 私があなたの替わりです」
> b「a さんの書類をください」
> スレッド「a くん, 君もう来なくていいから」
> a「」

「な, なるほど…ところで, セマンティクスってなんなんですかー?

「さっきの一連の流れを行うことで初めてムーブが成り立ちますよね. こういう複数の記述の組み合わせで成り立つものがセマンティクスです

*アイキャッチ*

「それでは, 先ほどの概念を扱うための C++ の言語機能に触れていきますね

「はーい♪

「こちらが, rvalue 参照です

```cpp
class Hoge;
void hoge(Hoge &&hoge) {
  // ...
}
```

「`&&` ってやるんだね. 値を渡すだけなら, 参照じゃダメなの?

「参照は実際にはポインタですから, 渡す側がもう値を使わないことを明示できる強みがあります

「普通の参照との違いってなんなの?

「普通の, いわゆる lvalue 参照とできることは変わりません. ただし lvalue 参照と違って明示的にキャストする必要があります

「キャストしてやるのかー

「このキャストの操作を担うのが, `std::move` です

「あ, だから rvalue 参照の引数だったらこれが要るんですね♪

「rvalue 参照は OK ですか?

「一つ気になるんだけど, lvalue 参照はよく `const` にするけど rvalue はどうなんですか?

「そうですね, 基本的に rvalue 参照を `const` にする意味はありません. ムーブ処理ではムーブ元のオブジェクトに手を加えることが多いですからね

「なるほどー

「次はさらなる特殊なメンバ関数, ムーブコンストラクタを見ていきましょう

「コピーコンストラクタみたいな感じ?

「そうですね. 同じ型の rvalue 参照から構築する関数です. この中で受け取った参照から値を取ってきたり, 受け取った参照が解放しないように加工します

「ふむふむ

「ムーブコンストラクタを定義すると, 暗黙のコピーコンストラクタが `= delete` されるので意図しないコピー動作を防ぐこともできます

「あ, ムーブしかなかったらコピーできなくなるんだ

「ムーブがなかったころは, この 2 択を迫られてました

1. 不整合を回避するためにコピー構築を手動実装する
2. クラス作者が不整合に気をつけてコピー構築の箇所でコピー元を null 化する

「ムーブ構築ができたことで, 整合性を保ちながらムーブセマンティクスが実現できるようになりました

「それでは例として `std::unique_ptr` の動作を見てみましょう

```cpp
using std::unique_ptr;
unique_ptr<int> a; // a に所有権はない
```

「まず, `unique_ptr` はデフォルト構築だと所有権を保持していません

「てことは, 解放処理は起こらないんですね？

「そうですね. そしてポインタを渡すことで所有権を保持していることになります

```cpp
unique_ptr<int> a{new int};
```

「こっちは `delete` で解放処理ってことなのね

「`unique_ptr` はコピーできませんが, ムーブすることはできます

```cpp
unique_ptr<int> a{new int};
unique_ptr<int> b{a}; // NG
unique_ptr<int> c{std::move(a)}; // OK
// 以降 a は使えない
```

「だいたいわかったかも♪

「また, コピーとムーブで別々の動作をさせるような書き方もできます. `std::vector` も見てみましょう

```cpp
using std::vector;
vector<int> a{0, 4, 3};
vector<int> b{a}; // コピー
vector<int> c{std::move(a)}; // ムーブ
// b と c だけが使える
```

「こっちはコピーとムーブのどっちもいけるんだね

「コピーの場合はコピー元も使い続けられますが, ムーブはできません

「これ, `move` があるからコンストラクタのオーバーロードができるんだね

「そんな感じです

「rvalue 参照の注意点として, 戻り値型に rvalue 参照型を使っても意味はありません

```cpp

```

「

「引数型の場合では,

```cpp

```

「

「原理的には, 以下のことをしているだけですね

1. スタック領域上のバイト列だけをコピーする
2. コピー元の解放処理をやらないようにする

「代入するとき勝手に全部コピーされるんじゃなくて、代入がムーブになる言語があったらいいのになー

「Rust という言語なら, ムーブがデフォになっていますね

「仕事で使ったりはしていませんが, システムプログラミング言語としては人気のようです

「ググってみたら, Stack Overflow の愛されてる言語ランキングで 4 年連続 1 位なんだって！

「C++ と似た部分が多いので, ねねさんみたいな物好きなら趣味でやっても楽しいと思いますよ

「Rust ってやつやってみます♪ありがとうございました

*ED*

ねねっち on SNS

「Rustマジで何しようとしてもコンパイルエラー出る

「Rust楽しい、、、

「Rust、言う事聞いてくれたときは嬉しい
そもそもコンパイルが通った時点で喜ぶ

「Rust、超難しい言語なんだろうなと勝手に思ってたけど、実際少し難しいけどコンパイラがめちゃくちゃ優しくて救いの手を差し伸べてくれるので、多分みんなやれば出来ると思う

（何か悪い影響を与えてしまったような気がする…）

---

動画: Mikuro さいな
監修: かわえもん

参考文献:

- Rust (プログラミング言語) - Wikipedia https://ja.wikipedia.org/wiki/Rust_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9E)
- Rust Programming Language https://www.rust-lang.org/
- The Rust Programming Language a.k.a. "The Book" https://doc.rust-lang.org/book/

---
