こにゃにゃちわ～, さいなです.

今回は「式と文と関数」について解説していくぞー.

# 式

Rust は式に重きを置いた言語なので, すべての処理が式になっている. そんな式のいくつかをみていこう.

## リテラル式

Rust では, すべてのリテラルが式だよ. 値を直接表現するための式だね.

```rust
843
'あ'
"Hello, world!"
```

## 演算子式

`+` や `*` といった演算子も式を作るよ.

```rust
1 + 2 <= 4 % 3
6 * 3 + 8 << 1
0.1 as f32 + 0.2f32
!false && true
```

優先順序はこんな感じ. まだ触れていない演算子は省いておいた.

1. 単項の `-` `!`
2. `as`
3. `*` `/` `%`
4. `+` `-`
5. `<<` `>>`
6. `&`
7. `^`
8. `|`
9. `==` `!=` `<` `>` `<=` `>=`
10. `&&`
11. `||`
12. 複合代入演算子

## グループ式

括弧の中に式を書くもので, この式の結果は中の式のものだよ. 俗に括弧式と言うね.

```rust
2 * (4 + 3)
```

## ブロック式

波括弧の中に文を書くもので, ブロック式の中の最後の式の結果がそれ自体の結果になるよ. ブロック式の結果を使いたい場合は, 最後の式に `;` を付けないように注意してね.

```rust
let hoge = {
  let fuga = 2;
  fuga + 3 // 結果となる式に ; を付けてはいけない
}; // hoge は 5
```

中身が空だったり `;` で終わってるなら, `()` と同じだよ.

```rust
let hoge = {}; // ()
let fuga = {
  5 + 2;
}; // ()
```

## if 式

Rust では条件分岐も式だよ. 普通の `if` だけなら結果は `()` になる.

```rust
if i < 0 {
  do_something();
} // ()
```

`if` - `else` の場合に各ブロックの結果が同じ型なら, 式としての真価が発揮される.

```rust
let message = if num % 2 == 0 {
  "even"
} else {
  "odd"
};
```

## ループ式

### 無限ループ

中のブロックを無限ループする式だよ. これ単体の結果は `!` という「処理が返ってこない」型だよ.

```rust
loop {

} // !
```

### break 式

`loop` の中で使うことで, その式の結果になるよ.

```rust
let mut count = 10;
let message = loop {
  count -= 1;
  if count <= 0 {
    break "ok"; // loop の結果になる
  }
};
```

ループを終了する目的でも使うよ. このとき, 最も近いところ以外を `break` するのにラベルが使えるよ.

```rust
'outer: loop {
  loop {
    break; // (A) に行く
  }
  // (A)
  loop {
    break 'outer; // (B) に行く
  }
  // (B)
}
```

### continue 式

`while` や `for` の中で次のループに進むための式だよ. こちらも `break` と同じようにラベルを使えるよ.

```rust
'outer: {
  let mut count = 10;
  loop {
    if count <= 0 {
      count = 10;
      continue;
    }
    // ...
    if 10 < count {
      continue 'outer;
    }
    // ...
    count -= 1;
  };
}
```

### 条件付きループ

`while` の後にループし続ける条件を書く式だよ.

```rust
let mut count = 10;
while 0 <= count {
  count -= 1;
}
```

単純な条件なら `while` でいいけど, 数値を順番に繰り返すような場合は次の `for` を使うよ.

### イテレータループ

`for` は, イテレータというものから要素を取り出してループする式だよ.

```rust
for item in iterator {
  // ...
}
```

`..` を使えば簡単な数列のイテレータが作れるよ. これを使えば C の `for` の書き方とはおさらばできる.

```rust
let mut i = 0;
while i < 10 {
  // ...
  i += 1;
}
// こんなことしなくてもこれだけでいい
for i in 0..10 {
  // ... i は 0 以上 10 未満
}
```

未満ではなく以下にしたいときは, `..=` を使う.

```rust
for i in 1..=10 {
  // ... i は 1 以上 10 以下
}
```

他にも配列のようなものまでイテレータにして繰り返せる.

```rust
for item in [1, 4, 2, 3, 5, 2, 3].iter() {
  // ...
}
```

# 文

`;` が付いたものが文だと思えばいいよ. 簡単でしょでしょ?

Rust の式はさっき説明した以外にもたくさんあるけど, 文はこの 5 つしかないよ.

1. 空文
2. 式文
3. 代入文
4. let 文
5. マクロ呼び出し

## 空文

`;` だけを書くと空文だよ.

```rust
;
```

## 式文

式の後ろに `;` を付けると式文になるよ.

```rust
1;
'Q';
{};
{} // {} の後の ; は無くても文になる
```

## 代入文

`mut` な変数に代入する文のことだよ.

```rust
let mut a = 2;
a = 0; // ← これ
```

## let 文

`let` も `;` で終わらないといけなくて, `let` 文って名前だよ.

```rust
let hoge = {
  let fuga = 2;
  fuga + 3
};
```

## マクロ呼び出し

Rust の関数には, 可変長な引数を受け取る機能は存在しないよ. だからマクロが使われるんだ. 最初に使った `println!` のように, `!` で終わるやつがマクロだよ.

```rust
println!("{}-{}", 33, 4);
```

`println!` のように関数みたいな使い方のマクロもあれば, 式や構文そのものを置き換えるようなマクロも存在するよ. まぁそれは後々ね.

ちなみに `println` マクロに使うフォーマット指定はいろいろと機能が多いので, ドキュメントとかを見てみてね.

# 関数

Rust で処理を書ける唯一のアイテムだよ. メイン関数も関数の一種だね. 場所を問わずに自由に定義できるよ.

ちなみに, Rust の関数名は snake_case にすることが推奨されてるよ.

```rust
fn do_nothing() {}

fn greet() {
  println!("Hello!");
}
```

```rust
fn main() {
  fn inner_a() {
    inner_b();
  }
  fn inner_b() {
    inner_a();
  }
  inner_a(); // stack overflow
}
```

## 戻り値

`()` の後に `-> 型` のように指定するんだ. 戻り値が存在する場合は省略できない.

```rust
fn do_nothing() -> () {}
```

関数の結果は中身の複式の結果なので, 戻り値に `;` を付けてはいけないよ. これはブロック式と同じだね.

```rust
fn random_number() -> i32 {
  4; // エラー, 戻り値がない
}
```

最後の式で戻らない場合は `return` 式を使うこともできる.

```rust
fn random_number() -> i32 {
  return 4; // ここで戻る
  0 // 処理はここまで進まない
}
```

## 引数

`()` の中に `名前1: 型1, 名前2: 型2, ...` と書くのだ.

```rust
fn add_then_print(a: i32, b: i32) -> i32 {
  println!("{}", a + b);
  a + b
}
```


## 呼び出し

関数を呼び出しするには, 関数名, 括弧, そして括弧の中に引数たちを書けばいい. 関数呼び出しも式だよ. この式の結果は戻り値になる.

```rust
fn add_then_print(a: i32, b: i32) -> i32 {
  println!("{}", a + b);
  a + b
}

fn main() {
  // i32 が返ってくるけど無視
  add_then_print(2, 5);
  // 返ってきたものを変数に代入する
  let result = add_then_print(4, 6);
}
```

# まとめ

今回のまとめだよ.

- 式がとても大事でたくさんある.
- 文は ; で終わるもの.
- 関数をどこにでも定義できるよ.
- 関数は引数で処理に必要な値を要求できる.
- 関数は戻り値で実行結果を返せる.
- 引数を付けて関数呼び出しする.
- 関数呼び出しも式になる.

ご視聴ありがとさん.

次回は, 「struct と enum」だよ.

---

動画: Mikuro さいな
監修: かわえもん

参考文献:

- The Rust Reference https://doc.rust-lang.org/stable/reference/
- Rust Programming Language https://www.rust-lang.org/
- The Rust Programming Language a.k.a. "The Book" https://doc.rust-lang.org/book/

---
